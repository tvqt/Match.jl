<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Match.jl</title><script data-outdated-warner src="assets/warner.js"></script><link rel="canonical" href="https://JuliaServices.github.io/Match.jl/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>Match.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Usage"><span>Usage</span></a></li><li><a class="tocitem" href="#Match-Values"><span>Match Values</span></a></li><li><a class="tocitem" href="#Match-Types"><span>Match Types</span></a></li><li><a class="tocitem" href="#Deep-Matching-of-Composite-Types"><span>Deep Matching of Composite Types</span></a></li><li><a class="tocitem" href="#Alternatives-and-Guards"><span>Alternatives and Guards</span></a></li><li><a class="tocitem" href="#Match-Ranges"><span>Match Ranges</span></a></li><li><a class="tocitem" href="#Regular-Expressions"><span>Regular Expressions</span></a></li><li><a class="tocitem" href="#Deep-Matching-Against-Arrays"><span>Deep Matching Against Arrays</span></a></li><li><a class="tocitem" href="#Notes/Gotchas"><span>Notes/Gotchas</span></a></li><li class="toplevel"><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Mathematica-Inspired-Sparse-Array-Constructor"><span>Mathematica-Inspired Sparse Array Constructor</span></a></li><li><a class="tocitem" href="#Matching-Exprs"><span>Matching Exprs</span></a></li><li class="toplevel"><a class="tocitem" href="#Inspiration"><span>Inspiration</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaServices/Match.jl/blob/main/docs/src/index.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Match.jl-–-Advanced-Pattern-Matching-for-Julia"><a class="docs-heading-anchor" href="#Match.jl-–-Advanced-Pattern-Matching-for-Julia">Match.jl –- Advanced Pattern Matching for Julia</a><a id="Match.jl-–-Advanced-Pattern-Matching-for-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Match.jl-–-Advanced-Pattern-Matching-for-Julia" title="Permalink"></a></h1><p>This package provides both simple and advanced pattern matching capabilities for Julia. Features include:</p><ul><li>Matching against almost any data type with a first-match policy</li><li>Deep matching within data types and matrices</li><li>Variable binding within matches</li></ul><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>Use the Julia package manager. Within Julia, do:</p><pre><code class="language-julia hljs">Pkg.add(&quot;Match&quot;)</code></pre><h1 id="Usage"><a class="docs-heading-anchor" href="#Usage">Usage</a><a id="Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Usage" title="Permalink"></a></h1><p>The package provides one macro, @match, which can be used as:</p><pre><code class="language-julia hljs">using Match

@match item begin
    pattern1              =&gt; result1
    pattern2, if cond end =&gt; result2
    pattern3 || pattern4  =&gt; result3
    _                     =&gt; default_result
end</code></pre><p>Patterns can be values, regular expressions, type checks or constructors, tuples, or arrays, including multidimensional arrays. It is possible to supply variables inside pattern, which will be bound to corresponding values. This and other features are best seen with examples.</p><h2 id="Match-Values"><a class="docs-heading-anchor" href="#Match-Values">Match Values</a><a id="Match-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Match-Values" title="Permalink"></a></h2><p>The easiest kind of matching to use is simply to match against values:</p><pre><code class="language-julia hljs">@match item begin
   1 =&gt; &quot;one&quot;
   2 =&gt; &quot;two&quot;
   _ =&gt; &quot;Something else...&quot;
end</code></pre><h2 id="Match-Types"><a class="docs-heading-anchor" href="#Match-Types">Match Types</a><a id="Match-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Match-Types" title="Permalink"></a></h2><p>Julia already does a great job of this with functions and multiple dispatch, and it is generally be better to use those mechanisms when possible. But it can be done here:</p><pre><code class="language-julia hljs">julia&gt; matchtype(item) = @match item begin
           n::Int               =&gt; println(&quot;Integers are awesome!&quot;)
           str::String          =&gt; println(&quot;Strings are the best&quot;)
           m::Dict{Int, String} =&gt; println(&quot;Ints for Strings?&quot;)
           d::Dict              =&gt; println(&quot;A Dict! Looking up a word?&quot;)
           _                    =&gt; println(&quot;Something unexpected&quot;)
   end

julia&gt; matchtype(66)
Integers are awesome!

julia&gt; matchtype(&quot;abc&quot;)
Strings are the best

julia&gt; matchtype(Dict{Int, String}(1=&gt;&quot;a&quot;,2=&gt;&quot;b&quot;))
Ints for Strings?

julia&gt; matchtype(Dict())
A Dict! Looking up a word?

julia&gt; matchtype(2.0)
Something unexpected</code></pre><h2 id="Deep-Matching-of-Composite-Types"><a class="docs-heading-anchor" href="#Deep-Matching-of-Composite-Types">Deep Matching of Composite Types</a><a id="Deep-Matching-of-Composite-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Deep-Matching-of-Composite-Types" title="Permalink"></a></h2><p>One nice feature is the ability to match embedded types, as well as bind variables to components of those types:</p><pre><code class="language-julia hljs">struct Address
    street::String
    city::String
    zip::String
end

struct Person
    firstname::String
    lastname::String
    address::Address
end

personinfo(person) = @match person begin
  Person(&quot;Julia&quot;, lname,  _)           =&gt; &quot;Found Julia $lname&quot;
  Person(fname, &quot;Julia&quot;, _)            =&gt; &quot;$fname Julia was here!&quot;
  Person(fname, lname,
         Address(_, &quot;Cambridge&quot;, zip)) =&gt; &quot;$fname $lname lives in zip $zip&quot;
  Person(_...)                         =&gt; &quot;Unknown person!&quot;
end

julia&gt; personinfo(Person(&quot;Julia&quot;, &quot;Robinson&quot;,
                  Address(&quot;450 Serra Mall&quot;, &quot;Stanford&quot;, &quot;94305&quot;)))
&quot;Found Julia Robinson&quot;

julia&gt; personinfo(Person(&quot;Gaston&quot;, &quot;Julia&quot;,
                  Address(&quot;1 rue Victor Cousin&quot;, &quot;Paris&quot;, &quot;75005&quot;)))
&quot;Gaston Julia was here!&quot;

julia&gt; personinfo(Person(&quot;Edwin&quot;, &quot;Aldrin&quot;,
                  Address(&quot;350 Memorial Dr&quot;, &quot;Cambridge&quot;, &quot;02139&quot;)))
&quot;Edwin Aldrin lives in zip 02139&quot;

julia&gt; personinfo(Person(&quot;Linus&quot;, &quot;Pauling&quot;,
                  Address(&quot;1200 E California Blvd&quot;, &quot;Pasadena&quot;, &quot;91125&quot;)))
&quot;Unknown person!&quot;</code></pre><h2 id="Alternatives-and-Guards"><a class="docs-heading-anchor" href="#Alternatives-and-Guards">Alternatives and Guards</a><a id="Alternatives-and-Guards-1"></a><a class="docs-heading-anchor-permalink" href="#Alternatives-and-Guards" title="Permalink"></a></h2><p>Alternatives allow a match against multiple patterns.</p><p>Guards allow a conditional match. They are not a standard part of Julia yet, so to get the parser to accept them requires that they are preceded by a comma and end with &quot;end&quot;:</p><pre><code class="language-julia hljs">function parse_arg(arg::String, value::Any=nothing)
  @match (arg, value) begin
    (&quot;-l&quot;,              lang)    =&gt; println(&quot;Language set to $lang&quot;)
    (&quot;-o&quot; || &quot;--optim&quot;, n::Int),
     if 0 &lt; n &lt;= 5 end           =&gt; println(&quot;Optimization level set to $n&quot;)
    (&quot;-o&quot; || &quot;--optim&quot;, n::Int)  =&gt; println(&quot;Illegal optimization level $(n)!&quot;)
    (&quot;-h&quot; || &quot;--help&quot;,  nothing) =&gt; println(&quot;Help!&quot;)
    bad                          =&gt; println(&quot;Unknown argument: $bad&quot;)
  end
end

julia&gt; parse_arg(&quot;-l&quot;, &quot;eng&quot;)
Language set to eng

julia&gt; parse_arg(&quot;-l&quot;)
Unknown argument: (&quot;-l&quot;,nothing)

julia&gt; parse_arg(&quot;-o&quot;, 4)
Optimization level set to 4

julia&gt; parse_arg(&quot;--optim&quot;, 5)
Optimization level set to 5

julia&gt; parse_arg(&quot;-o&quot;, 0)
Illegal optimization level 0!

julia&gt; parse_arg(&quot;-o&quot;, 1.0)
Unknown argument: (&quot;-o&quot;,1.0)

julia&gt; parse_arg(&quot;-h&quot;)
Help!

julia&gt; parse_arg(&quot;--help&quot;)
Help!</code></pre><h2 id="Match-Ranges"><a class="docs-heading-anchor" href="#Match-Ranges">Match Ranges</a><a id="Match-Ranges-1"></a><a class="docs-heading-anchor-permalink" href="#Match-Ranges" title="Permalink"></a></h2><p>Borrowing a nice idea from pattern matching in Rust, pattern matching against ranges is also supported:</p><pre><code class="language-julia hljs">julia&gt; function num_match(n)
           @match n begin
               0      =&gt; &quot;zero&quot;
               1 || 2 =&gt; &quot;one or two&quot;
               3:10   =&gt; &quot;three to ten&quot;
               _      =&gt; &quot;something else&quot;
           end
       end
num_match (generic function with 1 method)

julia&gt; num_match(0)
&quot;zero&quot;

julia&gt; num_match(2)
&quot;one or two&quot;

julia&gt; num_match(12)
&quot;something else&quot;

julia&gt; num_match(&#39;c&#39;)
&quot;something else&quot;</code></pre><p>Note that a range can still match another range exactly:</p><pre><code class="language-julia hljs">julia&gt; num_match(3:10)
&quot;three to ten&quot;</code></pre><h2 id="Regular-Expressions"><a class="docs-heading-anchor" href="#Regular-Expressions">Regular Expressions</a><a id="Regular-Expressions-1"></a><a class="docs-heading-anchor-permalink" href="#Regular-Expressions" title="Permalink"></a></h2><p>Match.jl used to have complex regular expression handling, but it was implemented using <code>eval</code>, which is generally a bad idea and was the source of some undesirable behavior.</p><p>With some work, it may be possible to reimplement, but it&#39;s unclear if this is a good idea yet.</p><h2 id="Deep-Matching-Against-Arrays"><a class="docs-heading-anchor" href="#Deep-Matching-Against-Arrays">Deep Matching Against Arrays</a><a id="Deep-Matching-Against-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Deep-Matching-Against-Arrays" title="Permalink"></a></h2><p>Arrays are intrinsic components of Julia. Match allows deep matching against arrays.</p><p>The following examples also demonstrate how Match can be used strictly for its extraction/binding capabilities, by only matching against one pattern.</p><h3 id="Extract-first-element,-rest-of-vector"><a class="docs-heading-anchor" href="#Extract-first-element,-rest-of-vector">Extract first element, rest of vector</a><a id="Extract-first-element,-rest-of-vector-1"></a><a class="docs-heading-anchor-permalink" href="#Extract-first-element,-rest-of-vector" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; @match([1:4], [a,b...]);

julia&gt; a
1

julia&gt; b
3-element SubArray{Int64,1,Array{Int64,1},(Range1{Int64},)}:
 2
 3
 4</code></pre><h3 id="Match-values-at-the-beginning-of-a-vector"><a class="docs-heading-anchor" href="#Match-values-at-the-beginning-of-a-vector">Match values at the beginning of a vector</a><a id="Match-values-at-the-beginning-of-a-vector-1"></a><a class="docs-heading-anchor-permalink" href="#Match-values-at-the-beginning-of-a-vector" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; @match([1:5], [1,2,a...])
 3-element SubArray{Int64,1,Array{Int64,1},(Range1{Int64},)}:
  3
  4
  5</code></pre><h3 id="Match-and-collect-columns"><a class="docs-heading-anchor" href="#Match-and-collect-columns">Match and collect columns</a><a id="Match-and-collect-columns-1"></a><a class="docs-heading-anchor-permalink" href="#Match-and-collect-columns" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; @match([1 2 3; 4 5 6], [a b...]);

julia&gt; a
2-element SubArray{Int64,1,Array{Int64,2},(Range1{Int64},Int64)}:
 1
 4

julia&gt; b
2x2 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 2 3
 5 6

julia&gt; @match([1 2 3; 4 5 6], [a b c]);

julia&gt; a
2-element SubArray{Int64,1,Array{Int64,2},(Range1{Int64},Int64)}:
 1
 4

julia&gt; b
2-element SubArray{Int64,1,Array{Int64,2},(Range1{Int64},Int64)}:
 2
 5

julia&gt; c
2-element SubArray{Int64,1,Array{Int64,2},(Range1{Int64},Int64)}:
 3
 6

julia&gt; @match([1 2 3; 4 5 6], [[1,4] a b]);

julia&gt; a
2-element SubArray{Int64,1,Array{Int64,2},(Range1{Int64},Int64)}:
 2
 5

julia&gt; b
2-element SubArray{Int64,1,Array{Int64,2},(Range1{Int64},Int64)}:
 3
 6</code></pre><h3 id="Match-and-collect-rows"><a class="docs-heading-anchor" href="#Match-and-collect-rows">Match and collect rows</a><a id="Match-and-collect-rows-1"></a><a class="docs-heading-anchor-permalink" href="#Match-and-collect-rows" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; @match([1 2 3; 4 5 6], [a, b]);

julia&gt; a
1x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 1 2 3

julia&gt; b
1x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 4 5 6

julia&gt; @match([1 2 3; 4 5 6; 7 8 9], [a, b...]);

julia&gt; a
1x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 1 2 3

julia&gt; b
2x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 4 5 6
 7 8 9

julia&gt; @match([1 2 3; 4 5 6], [[1 2 3], a])
1x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 4  5  6

julia&gt; @match([1 2 3; 4 5 6], [1 2 3; a])
1x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 4  5  6

julia&gt; @match([1 2 3; 4 5 6; 7 8 9], [1 2 3; a...])
2x3 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 4  5  6
 7  8  9</code></pre><h3 id="Match-individual-positions"><a class="docs-heading-anchor" href="#Match-individual-positions">Match individual positions</a><a id="Match-individual-positions-1"></a><a class="docs-heading-anchor-permalink" href="#Match-individual-positions" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; @match([1 2; 3 4], [1 a; b c]);

julia&gt; a
2

julia&gt; b
3

julia&gt; c
4

julia&gt; @match([1 2; 3 4], [1 a; b...]);

julia&gt; a
2

julia&gt; b
1x2 SubArray{Int64,2,Array{Int64,2},(Range1{Int64},Range1{Int64})}:
 3 4</code></pre><h3 id="Match-3D-arrays"><a class="docs-heading-anchor" href="#Match-3D-arrays">Match 3D arrays</a><a id="Match-3D-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Match-3D-arrays" title="Permalink"></a></h3><pre><code class="language-julia hljs">julia&gt; m = reshape([1:8], (2,2,2))
2x2x2 Array{Int64,3}:
[:, :, 1] =
 1 3
 2 4

[:, :, 2] =
 5 7
 6 8

julia&gt; @match(m, [a b]);

julia&gt; a
2x2 SubArray{Int64,2,Array{Int64,3},(Range1{Int64},Range1{Int64},Int64)}:
 1 3
 2 4

julia&gt; b
2x2 SubArray{Int64,2,Array{Int64,3},(Range1{Int64},Range1{Int64},Int64)}:
 5 7
 6 8

julia&gt; @match(m, [[1 a; b c] d]);

julia&gt; a
3

julia&gt; b
2

julia&gt; c
4

julia&gt; d
2x2 SubArray{Int64,2,Array{Int64,3},(Range1{Int64},Range1{Int64},Int64)}:
 5 7
 6 8</code></pre><h2 id="Notes/Gotchas"><a class="docs-heading-anchor" href="#Notes/Gotchas">Notes/Gotchas</a><a id="Notes/Gotchas-1"></a><a class="docs-heading-anchor-permalink" href="#Notes/Gotchas" title="Permalink"></a></h2><p>There are a few useful things to be aware of when using Match.</p><ul><li><p>Guards need a comma and an `end`:</p><h2>Bad</h2><pre><code class="nohighlight hljs">  julia&gt; _iseven(a) = @match a begin
          n::Int if n%2 == 0 end =&gt; println(&quot;$n is even&quot;)
          m::Int                 =&gt; println(&quot;$m is odd&quot;)
      end
  ERROR: syntax: extra token &quot;if&quot; after end of expression

  julia&gt; _iseven(a) = @match a begin
          n::Int, if n%2 == 0 =&gt; println(&quot;$n is even&quot;)
          m::Int              =&gt; println(&quot;$m is odd&quot;)
      end
  ERROR: syntax: invalid identifier name =&gt;</code></pre><h2>Good</h2><pre><code class="nohighlight hljs">  julia&gt; _iseven(a) = @match a begin
          n::Int, if n%2 == 0 end =&gt; println(&quot;$n is even&quot;)
          m::Int                  =&gt; println(&quot;$m is odd&quot;)
      end
  # methods for generic function _iseven
  _iseven(a) at none:1</code></pre></li><li><p>Without a default match, the result is `nothing`:</p><pre><code class="nohighlight hljs">  julia&gt; test(a) = @match a begin
              n::Int           =&gt; &quot;Integer&quot;
              m::FloatingPoint =&gt; &quot;Float&quot;
          end

  julia&gt; test(&quot;Julia is great&quot;)

  julia&gt;</code></pre></li><li><p>In Scala, _ is a wildcard pattern which matches anything, and is not bound as a variable.</p><p>In Match for Julia, _ can be used as a wildcard, and will be bound to the last use if it is referenced in the result expression:</p><pre><code class="nohighlight hljs">  julia&gt; test(a) = @match a begin
              n::Int           =&gt; &quot;Integer&quot;
              _::FloatingPoint =&gt; &quot;$_ is a Float&quot;
              (_,_)            =&gt; &quot;$_ is the second part of a tuple&quot;
          end

  julia&gt; test(1.0)
  &quot;1.0 is a Float&quot;

  julia&gt; test((1,2))
  &quot;2 is the second part of a tuple&quot;</code></pre></li><li><p>Note that variables not referenced in the result expression will not be bound (e.g., <code>n</code> is never bound above). One small exception to this rule is that when &quot;=&amp;gt;&quot; is not used, &quot;_&quot; will not be assigned.</p></li><li><p>If you want to see the code generated for a macro, you can use `macroexpand`:</p><pre><code class="nohighlight hljs">  julia&gt; macroexpand(:(@match(a, begin
                          n::Int           =&gt; &quot;Integer&quot;
                              m::FloatingPoint =&gt; &quot;Float&quot;
                          end))
  quote  # REPL[1], line 2:
      if isa(a,Int) # /Users/kevin/.julia/v0.5/Match/src/matchmacro.jl, line 387:
          &quot;Integer&quot;
      else  # /Users/kevin/.julia/v0.5/Match/src/matchmacro.jl, line 389:
          begin  # REPL[1], line 3:
              if isa(a,FloatingPoint) # /Users/kevin/.julia/v0.5/Match/src/matchmacro.jl, line 387:
                  &quot;Float&quot;
              else  # /Users/kevin/.julia/v0.5/Match/src/matchmacro.jl, line 389:
                  nothing
              end
          end
      end
  end</code></pre></li></ul><h1 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h1><p>Here are a couple of additional examples.</p><h2 id="Mathematica-Inspired-Sparse-Array-Constructor"><a class="docs-heading-anchor" href="#Mathematica-Inspired-Sparse-Array-Constructor">Mathematica-Inspired Sparse Array Constructor</a><a id="Mathematica-Inspired-Sparse-Array-Constructor-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematica-Inspired-Sparse-Array-Constructor" title="Permalink"></a></h2><p><a href="https://github.com/kmsquire/Match.jl/issues/29">Contributed by @benkj</a></p><blockquote><p>I&#39;ve realized that <code>Match.jl</code> is perfect for creating in Julia an equivalent of <a href="https://reference.wolfram.com/language/ref/SparseArray.html">SparseArray</a> which I find quite useful in Mathematica.</p><p>My basic implementation is this:</p><pre><code class="nohighlight hljs">macro sparsearray(size, rule)
    return quote
        _A = spzeros($size...)
        $(push!(rule.args, :(_ =&gt; 0)))

        for _itr in eachindex(_A)
            _A[_itr] = @match(_itr.I, $rule)
        end
        _A
    end
end</code></pre><p>Example:</p><pre><code class="nohighlight hljs">julia&gt; A = @sparsearray (5,5)  begin
               (n,m), if n==m+1 end =&gt; m
               (n,m), if n==m-1 end =&gt; n+10
               (1,5) =&gt; 1
       end</code></pre><p>which creates the matrix:</p><pre><code class="nohighlight hljs">julia&gt; full(A)
5x5 Array{Float64,2}:
 0.0  11.0   0.0   0.0   1.0
 1.0   0.0  12.0   0.0   0.0
 0.0   2.0   0.0  13.0   0.0
 0.0   0.0   3.0   0.0  14.0
 0.0   0.0   0.0   4.0   0.0</code></pre></blockquote><h2 id="Matching-Exprs"><a class="docs-heading-anchor" href="#Matching-Exprs">Matching Exprs</a><a id="Matching-Exprs-1"></a><a class="docs-heading-anchor-permalink" href="#Matching-Exprs" title="Permalink"></a></h2><p>The <code>@match</code> macro can be used to match Julia expressions (<code>Expr</code> objects). One issue is that the <a href="http://docs.julialang.org/en/release-0.4/manual/metaprogramming/#program-representation">internal structure of Expr objects</a> doesn&#39;t match their constructor exactly, so one has to put arguments in brackets, as well as capture the <code>typ</code> field of macros.</p><p>The following function is a nice example of matching expressions. It is used in <code>VideoIO.jl</code> to extract the names of expressions generated by <code>Clang.jl</code>, for later filtering and rewriting.:</p><pre><code class="language-julia hljs">extract_name(x) = string(x)
function extract_name(e::Expr)
    @match e begin
        Expr(:type,      [_, name, _])     =&gt; name
        Expr(:typealias, [name, _])        =&gt; name
        Expr(:call,      [name, _...])     =&gt; name
        Expr(:function,  [sig, _...])      =&gt; extract_name(sig)
        Expr(:const,     [assn, _...])     =&gt; extract_name(assn)
        Expr(:(=),       [fn, body, _...]) =&gt; extract_name(fn)
        Expr(expr_type,  _...)             =&gt; error(&quot;Can&#39;t extract name from &quot;,
                                                     expr_type, &quot; expression:\n&quot;,
                                                     &quot;    $e\n&quot;)
    end
end</code></pre><h1 id="Inspiration"><a class="docs-heading-anchor" href="#Inspiration">Inspiration</a><a id="Inspiration-1"></a><a class="docs-heading-anchor-permalink" href="#Inspiration" title="Permalink"></a></h1><p>The following pages on pattern matching in scala provided inspiration for the library:</p><ul><li><a href="http://thecodegeneral.wordpress.com/2012/03/25/switch-statements-on-steroids-scala-pattern-matching/">http://thecodegeneral.wordpress.com/2012/03/25/switch-statements-on-steroids-scala-pattern-matching/</a></li><li><a href="http://java.dzone.com/articles/scala-pattern-matching-case">http://java.dzone.com/articles/scala-pattern-matching-case</a></li><li><a href="http://kerflyn.wordpress.com/2011/02/14/playing-with-scalas-pattern-matching/">http://kerflyn.wordpress.com/2011/02/14/playing-with-scalas-pattern-matching/</a></li><li><a href="http://docs.scala-lang.org/tutorials/tour/case-classes.html">http://docs.scala-lang.org/tutorials/tour/case-classes.html</a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 13 June 2023 22:33">Tuesday 13 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
